\setcounter{page}{1}
\chapter{Prise en main de Git}
\label{label:prise_en_main_git}
\section{Configuration de votre git}

Une des premières étapes à effectuer lors de l'utilisation de git sur une nouvelle machine est sa configuration. Cette étape va permettre de vous identifier durant les avancées de vos projet (savoir qui a commit, qui a push, etc ...). 

\medskip

À l'aide de votre terminal créer un dossier qui fera office de dépôt de travail. \textbf{Placez vous dans ce dossier} et initialisez ce dossier comme un dépôt Git.

\medskip

Configurer votre git avant de commencer le cahier de TP sur votre terminal.


\section{Premier commit}

Dans ce dépôt, créer un fichier \textit{main.cpp} et écrivez un simple programme en C/C++ qui permet d'afficher sur le terminal le message "Hello, World!". Compiler et lancer le programme. 

\medskip

Avec la commande git appropriée ajouter uniquement le fichier que vous venez de créer pour qu'il soit prêt à être soumis au commit. Vérifier que vous l'avez ajouté avec la commande : \textbf{git status}.

\medskip

Commiter votre travail en mettant comme description du commit "Mon premier commit". Vérifier que vous avez bien commité grâce à la commande : \textbf{git log}. 

\medskip

Les commits sont des étapes importantes que ça soit pour du travail individuel ou collaboratif, ne négligez pas le nom que vous donnerez à vos commits car ils permettront de localiser l'avancement de vos projets pour vous et vos collègues.

\section{Gérer son dépôt}
Si vous vérifiez l'état de votre dépôt, vous remarquerez qu'il y a des fichiers binaires suivis (untracked) ou modifiés. L'outil Git permet d'indiquer quels sont les fichiers qu'on veut suivre et ceux qu'on ne veut pas. Cela permet d'avoir une meilleure traçabilité des fichiers modifiés.
\medskip

Pour cela configurer votre dépôt en ajoutant votre ".gitignore" pour qu'il ignore tous les fichiers à part ceux importants au projet. Dans ce cas la indiquer à git d'ignorer les fichiers binaires produits par le compilateur \textit{gcc}.

\medskip

A l'aide de la commande \textbf{git status}, verifier que les fichier sont bien ignorés. Ajouter le fichier \textbf{.gitignore} et commiter.

\newpage 

\chapter{Démineur} 

Durant cette seconde partie du TP vous allez devoir mettre en pratique les différentes commandes principales vu durant le cours sur Git. Vous allez devoir récupérer un dépôt distant sur Github pour venir travailler sur le projet en binôme ou groupe avant de le remettre sur un autre dépôt distant de compte rendu de votre travail.

~

L'objectif sera la réalisation d'un jeu sur votre shell, le démineur en C++, en manipulant simultanément l'outil Git.

%\section{Créez votre compte Github}
%
%Créer votre compte de travail sur le site Github !
%
%\medskip
%
%Inscrivez-vous grâce au lien suivant : \textbf{\href{https://github.com/join?source=login/}{https://github.com/join?source=login}}
%
\section{Cloner le dépôt distant du projet}

Grâce à votre terminal placez vous sur le bureau de votre session. Ensuite effectuer un : \textbf{git clone} du projet situé à cette url : 

\begin{center}
    \textbf{\href{https://github.com/Cours-Master-SME/Minesweeper\_template.git}{https://github.com/Cours-Master-SME/minesweeper\_template.git}}.
\end{center}



\section{Un dépôt pour deux}

Pour réaliser la suite du TP veuillez créer un seul dépôt distant \textbf{vide} sur votre compte Github parmi votre binôme en le nommant : \textbf{minesweeper\_nom1\_nom2}.

\section{Ajouter votre binôme à votre dépôt}

Maintenant que votre dépôt distant est crée sur Github inviter votre binôme de travail à se joindre à votre projet de TP. Pour cela dirigez vous dans l'onglet "Settings", ensuite allez dans "Manage access" et ajoutez votre binôme avec le bouton "Invite teams or people".

\section{Ajouter l'URL de votre dépôt distant}

Changer l'URL du dépôt du TP que vous avez cloné pour lui attribuer votre nouveau dépôt crée sur votre compte Github. %Pour cela utiliser les commandes : \textbf{git remote}.

\medskip

%git remote add origin https://github.com/YOUR\_ACCOUNT/YOUR\_REPO.git 
%
%git branch -M master
%
%git push -u origin master

\section{Développement en parallèle}

Il est temps de commencer à travailler sur le projet et de faire votre développement en vous mettant chacun dans un poste! %Répartissez vous maintenant le travail grâce à la création de deux branches. 

\medskip

L'un d'entre vous travaillera sur la branche \textbf{dev\_game} et l'autre sur la branche \textbf{dev\_cell}. Celui qui sera sur l'autre poste devra refaire la configuration de git voir \ref{label:prise_en_main_git}. \nameref{label:prise_en_main_git}.

Le binôme numéro 1 devra créer, sur son dépôt local, la branche \textbf{dev\_cell} et le binôme numéro 2 devra créer à son tour la branche \textbf{dev\_game}. Tapez dans votre terminal la commande git appropriée pour voir si votre branche de développement a été bien créée à côté de votre branche master.

\section{Fonctionnalité du jeu}
Le jeu démineur est un jeu à un joueur dont le but est de découvrir la \textit{grille} entière sans tomber sur une \textit{mine}. Si le joueur tombe sur une mine il a \textit{perdu}. Si le joueur découvre toute la grille sans \textit{tomber} sur une mine alors il a \textit{gagné}. Le jeu se déroule sur une grille de deux dimensions. Une case de la grille peut avoir une mine, vide, un chiffre qui indique le nombre de mines dans les cases voisines ou non découverte. Une case a huit voisins qui sont les cases adjacentes à elle même. Le joueur peut placer des drapeaux sur les cases s'il pense qu'une mine est presente.

\subsection{Fonctionnalité de la case}
L'objet \textit{\textbf{Cell}} correspondra à la case de la grille du démineur. Se placer sur la branche \textbf{dev\_cell} pour ajouter la fonctionnalité de la case. À vous de décider quand faire des commits et quels noms auront ces commits.

\medskip

\begin{itemize}
    \item Compléter la méthode \textit{\textbf{add\_mine}} qui permet d'affecter une mine à la case. Cette méthode permet d'affecter une mine à la case lors de l'initialisation du jeu.
    \medskip
    \item Compléter la méthode \textit{\textbf{get\_neighbours}} qui permet d'indiquer le nombre de mines que les cases voisines ont. Cette méthode est utilisé lors de l'affichage.
    \medskip
    \item Compléter la méthode \textit{\textbf{is\_discovered}} qui permet de savoir si la case a été découverte. Cette méthode est utilisée lors de l'affichage mais aussi lorsque l'on choisit de révéler une case.
    \medskip
    \item Compléter la méthode \textit{\textbf{is\_a\_mine}} qui permet d'indiquer si la case contient une mine. Cette méthode sera utilisée comme condition d'arrêt lorsqu'on découvre les cases par récursivité mais aussi pour afficher les mines lorsque l'on a perdu.
    \medskip
    \item Compléter la méthode \textit{\textbf{has\_neighbours}} qui permet de savoir si les cases voisines contient des mines. Cette méthode est utilisée aussi comme condition d'arrêt lorsqu'on découvre les cases par récursivité.
\end{itemize}

\subsection{Fonctionnalité de la grille}
L'objet \textit{\textbf{Game}} correspond à la plateforme du jeu qui va contenir la grille de cases. La grille est un vecteur de vecteur de cases (tableau à deux dimensions). Cet objet devra gérer l'affichage de la grille et la découverte de la grille dans un premier temps. Se placer sur la branche \textbf{dev\_game} pour ajouter la fonctionnalité du jeu. À vous de décider quand faire des commits et quels noms auront ces commits.

\medskip

\begin{itemize}
    \item Modifier la méthode \textit{\textbf{get\_width}} qui permet de retourner le nombre de colonnes de la grille. Cette méthode est utilisée pour borner le déplacement du joueur dans la grille au niveau des colonnes.
    \medskip
    \item Modifier la méthode \textit{\textbf{get\_height}} qui permet de retourner le nombre de lines de la grille. Cette méthode est utilisée pour borner le déplacement du joueur dans la grille au niveau des lignes.
\end{itemize}


\medskip

\section{Fusion des deux fonctionnalités}
Après avoir complété les deux fonctionnalités précédentes, fusionner la branche \textbf{dev\_cell} dans la branche \textbf{dev\_game} et tester le fonctionnement. Si vous n'avez pas le fonctionnement attendu, faire les modifications nécessaires (sur la classe \textit{Cell} ou \textit{Game}) sur la branche \textit{dev\_game}.

\section{Fonctionnalité de fin de jeu}
Si le joueur tombe sur une mine, le jeu doit savoir que le joueur a perdu et afficher un message en indiquant qu'il a perdu. Si le joueur découvre toutes les cases sans tomber sur une mine, le jeu doit indiquer qu'il a gagné et afficher un message indiquant qu'il a gagné.

\medskip

Sur la branche \textbf{dev\_game} ajouter les fonctionnalités suivantes : 
\begin{itemize}
    \item L'évènement qui permet de savoir si le joueur a découvert toutes les cases sans tomber sur une mine.
    \item L'évènement qui permet de savoir si le joueur est tombé sur une mine.
\end{itemize}

\medskip

Indice : La seule méthode à compléter/modifier est \textit{\textbf{Game::discover}}.

\medskip

Fusionner la branche \textbf{dev\_game} dans \textbf{master}. Ajouter ensuite le \textbf{tag v0.1.0} au dernier commit de la branche \textbf{master}. Pousser les commits vers dépôt distant.

\section{Fonctionnalité drapeau}
Dans le jeu démineur, on a la possibilité d'ajouter des drapeaux sur des cases si on pense qu'une mine s'y trouve. Créer une nouvelle branche \textbf{dev\_flag} et se déplacer dessus.
\medskip
\begin{itemize}
    \item Modifiez la méthode \textit{\textbf{is\_flagged}} pour indiquer si la cellule contient un drapeau. On utilise cette méthode, lors de l'affichage, pour marquer les cases qui ont un drapeau par un F.
    \medskip
    \item Modifier la méthode \textit{\textbf{flag}} qui permet de mettre un drapeau sur la case. Cette méthode est utilisée lorsque le joueur veut placer un drapeau sur la case.
    \medskip
    \item Modifier la méthode \textit{\textbf{unflag}} qui permet d'enlever un drapeau sur la case. Cette méthode est utilisée lorsque le joueur veut enlever un drapeau sur la case.
\end{itemize}

\medskip

Après avoir testé la fonctionnalité du drapeau, se placer fusionner la branche \textbf{dev\_flag} dans la branche \textbf{dev\_game}.

\medskip

Fusionner la branche \textbf{dev\_game} dans \textbf{master}. Ajouter ensuite le \textbf{tag v0.2.0} au dernier commit de la branche \textbf{master}. Pousser les commits vers dépôt distant.

%\section{Ajouter en dernier les enseignants à votre dépôt}
%
%Pour cette dernière étape il vous ai demandé d'ajouter les deux enseignants à vos dépôts distants pour venir récupérer votre travail. Vous trouverez les enseignants sous les pseudonymes suivants :
%
%\begin{itemize}
%    \item Pedro Carvalho Mendes : PedroCarvalho64  
%    \item Nicolas Otal : NicolasO-git
%\end{itemize}
% 9. Dans le fichier gacome.cpp suivez les consignes suivantes :
%     9.1 Modifier la méthode getX qui permet de retourner le nombre de Lignes. (Commit)
%     9.2 Modifier la méthode getY qui permet de retourner le nombre de Colonnes (Commit)
%     9.3 Modifier la méthode hasLost qui permet de retourner si la partie est gagnée.
%     9.4 Modifier la méthode haswon qui permet de retourner si la partie est perdue. 
% 
% 10. Mergez votre développement pour intégration à la branche principale
%     10.1 Mergez Dev_cells et Dev_Games dans la branche principale ou bien dans la branche Dev_cells 
%     dans la branche Dev_Games puis dans la principale.
% 
% 11. Ajouts de la fonctionnalité Drapeau
%     11.1 Modifier la méthode isFlagged qui permet d'indiquer si la cellule est un drapeau. (No commit)
%     11.2 Compléter la méthode flag qui permet de d'enlever ou d'ajouter un drapeau. (No commit)
%     11.3 Une erreur ? Un problème ? Stash ?
% 
% 12. Ajoutez les enseignants a vos projets pour qu'ils puissent les récupérer en fin de séance
\newpage
\chapter{Jeu de la vie}

\textit{Le Jeu de la vie est un automate cellulaire imaginé par John Horton Conway en 1970. Malgré des règles très simples, il est Turing-complet. C'est un jeu de simulation au sens mathématique.}

\medskip

Le jeu de la vie est un jeu à zéro joueurs car il ne nécessite aucune intervention du joueur. C'est un automate cellulaire où son état suivant sera calculé à partir de son état présent à partir de règles pre-établies.

\medskip

Le jeu se déroule sur une grille à deux dimensions, théoriquement infinie (dans notre cas il sera fini), dont les cases sont appelés des cellules. Une cellule a deux états ("vivante" ou "morte") et contient huit voisins qui sont les cellules adjacentes à elle même.

\medskip

A chaque itération, le jeu évolue selon les règles suivantes :

\medskip

\begin{itemize}
    \item Une cellule morte possédant exactement trois cellules voisines vivantes devient vivante (elle naît);
    \medskip
    \item Une cellule vivante possédant deux ou trois cellules voisines vivantes le reste, sinon elle meurt;
\end{itemize}

\section{Mise en place du projet}
Cloner le dépôt <url vers depot> qui contient modelé du jeu avec des méthodes à compléter.
Avec \textit{CMake}, configurer le projet, compiler et exécuter le programme.

\section{Développement en parallèle}
Créer deux branches de développement \textbf{dev\_game} et \textbf{dev\_cell} qui aura pour but de faire du développement en parallèle. 

\subsection{Classe \textit{Cell}}
La classe \textit{Cell}, correspond à la cellule du jeu de la vie. Comme c'est décrit dans les règles du jeu de la vie, la cellule a deux états distincts (\textit{Vivante} ou \textit{Morte}) et huit voisins qui sont les cellules adjacentes par rapport à elle même.

\medskip

Se placer dans la branche \textbf{dev\_cell} et faire des commits à chaque nouvelle fonctionnalité.

\medskip

\begin{itemize}
    \item Compléter la méthode \textbf{set\_status} qui permet de rendre la cellule \textit{Vivante} ou \textit{Morte}.
    \medskip
    \item Compléter la méthode \textbf{is\_alive} qui permet de savoir si la cellule est vivante ou non.
\end{itemize}

\medskip

Pousser les commits vers le dépôt distant.

\subsection{Classe \textit{Game}}
La classe \textbf{Game}, correspond au comportement de l'automate cellulaire où il va calculer l'état suivant du jeu en fonction de son état actuel. L'attribut \textit{\_grid}, est un vecteur de vecteur de la classe \textit{Cell} (tableau à deux dimensions) qui correspondra à la grille de cellules décrite dans un peu plus haut.

\medskip

Se placer dans la branche \textit{dev\_game} et faire des commits à chaque nouvelle fonctionnalité.

\medskip

Compléter la méthode \textit{iterate} qui permet de calculer l'état suivant de la grille en fonction de l'état actuel en respectant les règles du jeu.

\medskip

Pousser les commits vers le dépôt distant.

\section{Fusion des deux classes}
Se placer dans la branche \textbf{dev\_game} et fusionner branche \textbf{dev\_cell} pour intégrer les fonctionnalités de la classe \textit{Cell}. Si vous n'avez pas le fonctionnement attendu, faire les modifications nécessaires (sur la classe \textit{Cell} ou \textit{Game}) sur la branche \textit{dev\_game}.


\section{Detection de fin de simulation}
Dans la simulation du jeu de la vie, il se peut que la configuration initiale de la grille puisse donner où plus aucune cellule sera vivante. 

\medskip

Compléter la méthode \textbf{iterate} de la classe \textbf{Game} pour savoir combien de cellules sont vivantes dans la grille

\medskip

Compléter la méthode \textbf{get\_number\_of\_living\_cells} qui permet de récupérer le nombre de cellules vivantes sur la grille.

\medskip

Dans le fichier \textit{main.cpp}, compléter dans la boucle \textit{do while}, la condition pour arrêter la simulation.

\section{Intégration dans la branche principale}
Fusionner dans la branche \textbf{master} la branche \textbf{dev\_game}.

Ajouter dans \textbf{main.cpp}, la possibilité que l'utilisateur puisse rentrer la taille de la grille qu'il veut.

\medskip

Fusionner la branche \textbf{dev\_game} dans \textbf{master}. Ajouter ensuite le \textbf{tag v1.0.0} au dernier commit de la branche \textbf{master}. Pousser les commits vers dépôt distant.